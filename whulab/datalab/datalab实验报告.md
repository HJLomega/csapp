## 一、实验目的

本实验目的是加强学生对位级运算的理解及熟练使用的能力。

## 二、报告要求

本报告要求学生把实验中实现的所有函数逐一进行分析说明，写出实现的依据，也就是推理过程，可以是一个简单的数学证明，也可以是代码分析，根据实现中你的想法不同而异。

## 三、函数分析

### 1. bitXor函数

**函数要求：**

函数名 | bitXor
-|-
参数 | int , int
功能实现 | x^y
要求 | 只能使用 ~ 和 | 运算符，将结果返回。

**实现分析：**

a^b = ~x & ~y;


**函数实现：**

```C
int bitXor(int x, int y) {
  // 代码实现
  ~x & ~y;
}
```

### 2. copyLSB函数

**函数要求：**

函数名 |copyLSB 
-|-
参数 | int
功能实现 | 拷贝最低位
要求 | 只用! ~ & ^ | + << >>

**分析：**
利用算术右移，先`x<<31`再`x>>31`.

**函数实现：**

```C
int bitAnd (int x, int y) {

 // 代码实现
 return (x<<31)>>31;
}
```
### 3. isEqual函数

**函数要求：**

函数名 |isEqual
-|-
参数 | int int 
功能实现 | 判断 x == y
要求 | 只用! ~ & ^  + << >> 

**分析：**
利用异或的性质：`x^x=0`,返回 `!(x^y)` 即可

### 4. bitMask函数

**函数要求：**

函数名 |bitMask
-|-
参数 | int int 
功能实现 | 创建一个 l 和 h间 全为1的掩码
要求 | 只用! ~ & ^  + << >>

**分析：**
    1. 利用算术右移，生成一个从最高位到`lowbit`全为1数：`int high1 = (1<<31)>>(32+~lowbit); `
    2. 再利用算术右移，创建一个生成一个从最高位到`highbit`前一位全为1掩码`int mask = (1<<31)>>(32+~highbit)<<1; `
    3. 将高位设置为0:`return high1 & ~mask;` 

### 5. bitCount函数

**函数要求：**

函数名 |
-|-
参数 | 
功能实现 |
要求 | 只用! ~ & ^  + << >>

**分析：**
    1. 想办法将所有的1加到一起。
    2. 可以通过将奇数位的bit错位加到偶数位，并用相邻的两个bit来存储结果（此时每两位存储的数表示这两位最开始含有的1），并以此类推，直到最后算出用32位来表示结果（此时int中的数表示总共32位最开始含有的1）。一共需要5次错位叠加。


### 6. tmax函数

**函数要求：**

函数名 | tmax
-|-
参数 | void
功能实现 | 返回最大的补码
要求 | 只用! ~ & ^  + << >>

**分析：**
tmax为`0x7fffffff`，故返回`~(1<<31)`即可

### 7. isNonNegative函数

**函数要求：**

函数名 |isNonNegative
-|-
参数 | int 
功能实现 | x>=0
要求 | 只用! ~ & ^  + << >>

**分析：**
将`x`右移31位，若为`x`正则为`0x0`，若`x`为负,则为`0xffffffff`.故返回`!(x>>31)`即可

### 8. addOK函数

**函数要求：**

函数名 |addOK
-|-
参数 | int int 
功能实现 | 监测x+y是否溢出
要求 | 只用! ~ & ^  + << >>

**分析：**
    1. 若异号，不会溢出。 
    2. 若同号，则判断两数之和的最高位与加数中的任一数最高位是否相同即可，若相同则为发生溢出，反之。
    3. 可用`(x^y)>>31`判断同号还是异号。


### 9. rempwr2函数

**函数要求：**

函数名 |rempwr2
-|-
参数 | int int 
功能实现 | 计算 x%(2^n) ,负数应为负值
要求 | 只用! ~ & ^  + << >>

**分析：**
    1. 获得符号 :`int xsign = (x>>31);`
    2. 取根据`xsign`取绝对值: `int abs = (x^xsign) + (1^(!xsign));` （取绝对值的思路可参见第11个函数）
    3. 创建将n到最高位置零的掩码:`int mask = (1<<(n))+(~0); `
    4. 将n到最高位置零再次并根据`xsign`取绝对值: `return ((mask & abs)^(xsign))+(1^(!xsign));`

### 10. isLess函数

**函数要求：**

函数名 |isLess
-|-
参数 | int int 
功能实现 | 比较 x<y
要求 | 只用! ~ & ^  + << >>

**分析：**
    1. 若x >0, y<0，返回0
    2. 若x <0, y>0，返回1
    3. 若同号，根据x-y 的符号判断即可。 

**函数实现：**

```C
int bitXor(int x, int y) {
  // 代码实现
  int dif = x + ~y +1 ;
  int sign = dif>>31;
  int xp = !(x>>31);
  int yp = !(y>>31);
  int pn = (xp)&(!yp);
  int np = (!xp)&(yp);
  return   np | ((!pn) & (!!sign)) ;
}
```
### 11.  absVal函数

**函数要求：**

函数名 |absVal函数
-|-
参数 | int 
功能实现 | x>0?x:-x
要求 | 只用! ~ & ^  + << >>

**分析：**
    1. 获得符号: `int xsign = (x>>31);`
    2. 由于`x^1 == ~x`和`x^0 == x`。再者当`x>=0`时`xsign == 0`,当`x<0`时`xsign == 0xffffffff`.故以下代码实现受控取反加1：
    `return (x^xsign) + (1^(!xsign));`

### 12. isPower2函数

**函数要求：**

函数名 |isPower2
-|-
参数 | int 
功能实现 | 判断是否为2的次幂，0不是。
要求 | 只用! ~ & ^  + << >>

**分析：**
    1. 若`x`为2的次幂，则`x`的bit表示只有一个1 ，而`x-1`在那个’1‘后面全为1，故`x&(x-1)==0`
    2. 返回 `(!!x) & (~(x>>31))) & (!(x&(x+~0)))) `即可,其中第一项处理`x==0`的情况,第二项处理`x<0`的情况。
   
### 13.  float_neg函数

**函数要求：**

函数名 |float_neg函数
-|-
参数 | unsigned
功能实现 | 返回浮点数的相反数的位表示
要求 | 只用int 、usign 的操作符和if while

**分析：**
    1. 获得指数`exp`和指数`frac`
    2. 利用指数和小数判断`uf`是否为NaN.若是，则直接原值返回；若不是，则将最高位取反再返回。 
   
### 14. float_half函数

**函数要求：**

函数名 |float_half
-|-
参数 | unsigned
功能实现 | 获得浮点数一半的位表示
要求 |  只用int 、usign 的操作符和if while

**分析：**
    1. 获得指数`exp`和小数`frac`
    2. 如果`uf`为无穷或NaN，返回原值
       1. 若exp为0或1，则小数加一再右移，并判断是否要向偶数舍入，为1是要将exp设为0，并将frac的最高位一置零
       2. 其他情况，exp减一即可。
    3. 构造并返回新的浮点数。   

### 15.   float_i2f函数

**函数要求：**

函数名 |float_i2f
-|-
参数 | int
功能实现 | 获得从int转化位float的位表示
要求 |  只用int 、usign 的操作符和if while

**分析：**
    1. 获得符号`unsigned sign = x & (1 << 31);`
    2. 获得绝对值 `absX`
    3. 将`absX`右移直到为0，用`exp`记录右移位数，exp即为指数（未偏置）。
    4. 获取损失位`round`和float小数部分`frac` （由于int转化位float最多损失9位，故可将损失的第一位放在`round`的第九位以方便比较）
    5. 比较`round`和`0xff + 1`以确定，是舍，是入，还是想偶数舍入。
    6. 合成f。

## 四、实验总结

在本段总结实验中遇到的问题或困难，以及对应的解决方法；对实验的建议等：
 - 通过datalab，我充分理解了位操作，领会到了异或、移位这两个运算符的强大，对int 和 float 的各种特性也有了更升入的理解。
 -  在实验中有时会卡壳，此时，我通过无视运算符限制，先把基本的逻辑用c语言写清楚，通过测试。然后在想办法根据所写的c语言翻译成只用位运算的c语言，这样使我解决了很多难题。