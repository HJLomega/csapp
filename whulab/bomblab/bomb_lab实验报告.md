### phase_1

```txt
   0x0000000000400e45 <+136>:	call   0x4016a1 <read_line>
   0x0000000000400e4a <+141>:	mov    %rax,%rdi
   0x0000000000400e4d <+144>:	call   0x400ef0 <phase_1>

```
调用phase_前从用户读输入
接收一个字符，存在%rdi中，然后调用phase_1
```txt
   0x0000000000400ef0 <+0>:	sub    $0x8,%rsp
   0x0000000000400ef4 <+4>:	mov    $0x40257c,%esi
   0x0000000000400ef9 <+9>:	call   0x40137e <strings_not_equal>
   0x0000000000400efe <+14>:	test   %eax,%eax 
   0x0000000000400f00 <+16>:	je     0x400f07 <phase_1+23>
   0x0000000000400f02 <+18>:	call   0x401629 <explode_bomb>
   0x0000000000400f07 <+23>:	add    $0x8,%rsp
   0x0000000000400f0b <+27>:	ret    
```
要比较%rdi和%esi，相同炸弹解除，通过`x /s 0x40257c`知道目标字符串为`Public speaking is very easy.`
所以第一关的答案是`Public speaking is very easy.`

### phase_2
**第一部分**
```
   0x0000000000400f12 <+6>:	mov    %rsp,%rsi
   0x0000000000400f15 <+9>:	call   0x40165f <read_six_numbers>
   0x0000000000400f1a <+14>:	cmpl   $0x0,(%rsp)
   0x0000000000400f1e <+18>:	jns    0x400f44 <phase_2+56>
```
读六个数字，存在栈中，以%rsp所指处为起始位置

**第二部分**
```
   0x0000000000400f1a <+14>:	cmpl   $0x0,(%rsp)    #将第一个数与零比较
   0x0000000000400f1e <+18>:	jns    0x400f44 <phase_2+56>
   0x0000000000400f20 <+20>:	call   0x401629 <explode_bomb>
   ```
第一个数必须为非负，随后程序跳到<+56处>
```
   0x0000000000400f44 <+56>:	lea    0x4(%rsp),%rbp
   0x0000000000400f49 <+61>:	mov    $0x1,%ebx
   0x0000000000400f4e <+66>:	jmp    0x400f27 <phase_2+27>
   0x0000000000400f50 <+68>:	add    $0x28,%rsp
   0x0000000000400f54 <+72>:	pop    %rbx
   0x0000000000400f55 <+73>:	pop    %rbp
   0x0000000000400f56 <+74>:	ret    
   ```
这段代码是循环初始化，将%rsp+0x4 （即第二个数的地址）赋给了%rbp，可见%rbp是一个指针，记为int *bp，然后将%ebx 赋初值1，可见%ebx应该为循环变量，记为int bx，最后跳到<+27>处。
```
   0x0000000000400f27 <+27>:	mov    %ebx,%eax
   0x0000000000400f29 <+29>:	add    -0x4(%rbp),%eax
   0x0000000000400f2c <+32>:	cmp    %eax,0x0(%rbp)
   0x0000000000400f2f <+35>:	je     0x400f36 <phase_2+42>
   0x0000000000400f31 <+37>:	call   0x401629 <explode_bomb>
   0x0000000000400f36 <+42>:	add    $0x1,%ebx
   0x0000000000400f39 <+45>:	add    $0x4,%rbp
   0x0000000000400f3d <+49>:	cmp    $0x6,%ebx
   0x0000000000400f40 <+52>:	jne    0x400f27 <phase_2+27>
   0x0000000000400f42 <+54>:	jmp    0x400f50 <phase_2+68>
   ```
先将 bp前一个数与bx之和赋给了%rax，即`int ax = bx + bp[-1];`，然后是分支，若`ax == *bp`，则跳到循环变量更新处，`bx+=1;bp+=1;`,5个数字后停止循环,程序返回。故后面的第i个数应该依此与前一个数差i-1（1，2，3，4，5）。

取第一个数为0,故答案可以是`0 1 3 6 10 15`
### phase_3
**第一部分，读取输入**
```
   0x0000000000400f57 <+0>:	sub    $0x18,%rsp
   0x0000000000400f5b <+4>:	lea    0x8(%rsp),%r8
   0x0000000000400f60 <+9>:	lea    0x7(%rsp),%rcx
   0x0000000000400f65 <+14>:	lea    0xc(%rsp),%rdx
   0x0000000000400f6a <+19>:	mov    $0x40259a,%esi
   0x0000000000400f6f <+24>:	mov    $0x0,%eax
   0x0000000000400f74 <+29>:	call   0x400c30 <__isoc99_sscanf@plt>
   0x0000000000400f79 <+34>:	cmp    $0x2,%eax
   0x0000000000400f7c <+37>:	jg     0x400f83 <phase_3+44>
 ```
通过`x /s 0x40259a`,结果为```"%d %c %d"``，所以要读两个int数一个char字符，通过传参顺序和数据大小可知0xc(%rsp) 为第一个数，0x7(%rsp)为字符，0x8(%rsp)为第二个数，依此记为`int i1;int ch;int i2;`,随后程序跳掉<+44>处

**第二部分,switch**
```
    0x0000000000400f83 <+44>:	cmpl   $0x7,0xc(%rsp)
   0x0000000000400f88 <+49>:	ja     0x401083 <phase_3+300> #<+300> 爆炸
   0x0000000000400f8e <+55>:	mov    0xc(%rsp),%eax
   0x0000000000400f92 <+59>:	jmp    *0x4025c0(,%rax,8)
```
第一个跳转说明，必须有`i2<=7`,否则爆炸。随后`int a = i2`，随后是个switch的跳转。跳转表位于0x4025c0，查看跳转表`0x4025c0`,得
```
0x4025c0:	0x0000000000400f99	0x0000000000400fbb
0x4025d0:	0x0000000000400fdd	0x0000000000400fff
0x4025e0:	0x000000000040101a	0x0000000000401035
0x4025f0:	0x000000000040104d	0x0000000000401068
```
若a=0，跳到0x400f99处，代码如下
```
   0x0000000000400f99 <+66>:	mov    $0x74,%eax
   0x0000000000400f9e <+71>:	cmpl   $0x302,0x8(%rsp)
   0x0000000000400fa6 <+79>:	je     0x40108d <phase_3+310>
   0x0000000000400fac <+85>:	call   0x401629 <explode_bomb>
```
先赋值`%eax = 0x74`，并且必须有`i2 == 0x302 == 770`,跳到<+310>
```
   0x000000000040108d <+310>:	cmp    0x7(%rsp),%al
   0x0000000000401091 <+314>:	je     0x401098 <phase_3+321>
   0x0000000000401093 <+316>:	call   0x401629 <explode_bomb>
    0x0000000000401098 <+321>:	add    $0x18,%rsp
   0x000000000040109c <+325>:	ret    
```
ch等于%al（0x74），即ch 为't'
故答案为`0 t 770`
若a=1，跳到0x400fbb处。（原理同上，故下面都不展示汇编代码了）
先赋值`%eax = 0x6e`，并且必须有`i2 == 0xc6`,跳到<+310>
故答案为`1 n 198`
若a=2，跳到0x400fdd处。
先赋值`%eax = 0x56`，并且必须有`i2 == 0x307`,跳到<+310>
故答案为`2 V 775`
若a=3，跳到0x400fff处。
先赋值`%eax = 0x44`，并且必须有`i2 == 0x337`,跳到<+310>
故答案为`3 D 823`
若a=4，跳到0x40101a处。
先赋值`%eax = 0x6f`，并且必须有`i2 == 0xad`,跳到<+310>
故答案为`4 o 173`
若a=5，跳到0x401035处。
先赋值`%eax = 0x49`，并且必须有`i2 == 0x64`,跳到<+310>
故答案为`5 I 100`
若a=6，跳到0x40104d处。
先赋值`%eax = 0x4f`，并且必须有`i2 == 0x130`,跳到<+310>
故答案为`6 O 304`
若a=6，跳到0x401068处。
先赋值`%eax = 0x51`，并且必须有`i2 == 0x234`,跳到<+310>
故答案为`7 Q 564`

综上所述，可通过的所有答案为：（一行为一个答案）
```
0 t 770
1 n 198
2 V 775
3 D 823
4 o 173
5 I 100
6 O 304
7 Q 564
```
### phase_4
**第一部分，读取输入**
```
   0x00000000004010d0 <+0>:	sub    $0x18,%rsp
   0x00000000004010d4 <+4>:	lea    0x8(%rsp),%rcx
   0x00000000004010d9 <+9>:	lea    0xc(%rsp),%rdx
   0x00000000004010de <+14>:	mov    $0x402889,%esi
   0x00000000004010e3 <+19>:	mov    $0x0,%eax
   0x00000000004010e8 <+24>:	call   0x400c30 <__isoc99_sscanf@plt>
   0x00000000004010ed <+29>:	cmp    $0x2,%eax
   0x00000000004010f0 <+32>:	jne    0x4010f9 <phase_4+41>  #<+41> 爆炸
   ```
输入`x /s 0x402889`得"%d %d",故输入为两个int数，通过传参顺序和数据大小可知0xc(%rsp) 为第一个数、0x8(%rsp) 为第二个数，依此记为`int i1,i2;`。随后顺序执行代码

**第二部分**
```
    0x00000000004010f0 <+32>:	jne    0x4010f9 <phase_4+41>
   0x00000000004010f2 <+34>:	cmpl   $0xe,0xc(%rsp)
   0x00000000004010f7 <+39>:	jbe    0x4010fe <phase_4+46>
   0x00000000004010f9 <+41>:	call   0x401629 <explode_bomb>
   0x00000000004010fe <+46>:	mov    $0xe,%edx
   0x0000000000401103 <+51>:	mov    $0x0,%esi
   0x0000000000401108 <+56>:	mov    0xc(%rsp),%edi
   0x000000000040110c <+60>:	call   0x40109d <func4>
   ```
这段代码先检查了输入参数，必须有`i1<=0xe`，即`i1<=14`，然后调用了`func4(i1,0,14)`.
查看func4的代码,如下：
```
   0x000000000040109d <+0>:	push   %rbx
   0x000000000040109e <+1>:	mov    %edx,%eax
   0x00000000004010a0 <+3>:	sub    %esi,%eax
   0x00000000004010a2 <+5>:	mov    %eax,%ebx
   0x00000000004010a4 <+7>:	shr    $0x1f,%ebx
   0x00000000004010a7 <+10>:	add    %ebx,%eax
   0x00000000004010a9 <+12>:	sar    %eax
   0x00000000004010ab <+14>:	lea    (%rax,%rsi,1),%ebx
   0x00000000004010ae <+17>:	cmp    %edi,%ebx
   0x00000000004010b0 <+19>:	jle    0x4010be <func4+33>
   0x00000000004010b2 <+21>:	lea    -0x1(%rbx),%edx
   0x00000000004010b5 <+24>:	call   0x40109d <func4>
   0x00000000004010ba <+29>:	add    %ebx,%eax
   0x00000000004010bc <+31>:	jmp    0x4010ce <func4+49>
   0x00000000004010be <+33>:	mov    %ebx,%eax
   0x00000000004010c0 <+35>:	cmp    %edi,%ebx
   0x00000000004010c2 <+37>:	jge    0x4010ce <func4+49>
   0x00000000004010c4 <+39>:	lea    0x1(%rbx),%esi
   0x00000000004010c7 <+42>:	call   0x40109d <func4>
   0x00000000004010cc <+47>:	add    %ebx,%eax
   0x00000000004010ce <+49>:	pop    %rbx
   0x00000000004010cf <+50>:	ret    
  ```

可用c语言重写为

``` c
int func4(int di, int si, int dx) {
	int bx;
	int ax = dx - si;
	ax += (ax >> 31) & 0x1;
	ax >>= 1;
	bx = ax + si;
	if (di < bx) {
		return f4(di, si, bx - 1) + bx;
	}
	else if (di == bx) {
		return bx;
	}
	else {
		return f4(di, 1 + bx, dx) + bx;
	}
}
 ```
**最后一部分**
```
   0x0000000000401111 <+65>:	cmp    $0x2b,%eax
   0x0000000000401114 <+68>:	jne    0x40111d <phase_4+77>
   0x0000000000401116 <+70>:	cmpl   $0x2b,0x8(%rsp)
   0x000000000040111b <+75>:	je     0x401122 <phase_4+82>
   0x000000000040111d <+77>:	call   0x401629 <explode_bomb>
   0x0000000000401122 <+82>:	add    $0x18,%rsp
   0x0000000000401126 <+86>:	ret    
 ```
可见`func4(i1,0,14)`的返回值必须为`0x2b`，即`func4(i1,0,14)==43`,并且有`i2 == 43`,枚举得
```
func4(0,0,14) = 11
func4(1,0,14) = 11
func4(2,0,14) = 13
func4(3,0,14) = 10
func4(4,0,14) = 19
func4(5,0,14) = 15
func4(6,0,14) = 21
func4(7,0,14) = 7
func4(8,0,14) = 35
func4(9,0,14) = 27
func4(10,0,14) = 37
func4(11,0,14) = 18
func4(12,0,14) = 43
func4(13,0,14) = 31
func4(14,0,14) = 45
 ```
则i1为12时func4(i1,0,14) = 43
故答案为`12 43`
### phase_5
**第一部分**
```  
   0x0000000000400eb5 <+248>:	call   0x4016a1 <read_line>
   0x0000000000400eba <+253>:	mov    %rax,%rdi
   0x0000000000400ebd <+256>:	call   0x401127 <phase_5>
```
读取一行输入，存在rdi中,记为`char *s;`，随后调用phase_5

**第二部分**
```
   0x0000000000401128 <+1>:	mov    %rdi,%rbx
   0x000000000040112b <+4>:	call   0x401361 <string_length> #计算%rdi（即s）字符串的长度
   0x0000000000401130 <+9>:	cmp    $0x6,%eax
   0x0000000000401133 <+12>:	je     0x40113a <phase_5+19>
   0x0000000000401135 <+14>:	call   0x401629 <explode_bomb>
```
先将%rdi(即字符串的地址)赋给%rbx,设%rbx为`char *bx`,记为`char *bx = s`.随后依据字符串长度判断可知要输入6个字符
```
   0x000000000040113a <+19>:	mov    $0x0,%eax
   0x000000000040113f <+24>:	mov    $0x0,%edx
   0x0000000000401144 <+29>:	movzbl (%rbx,%rax,1),%ecx
   0x0000000000401148 <+33>:	and    $0xf,%ecx
   0x000000000040114b <+36>:	add    0x402600(,%rcx,4),%edx
   0x0000000000401152 <+43>:	add    $0x1,%rax
   0x0000000000401156 <+47>:	cmp    $0x6,%rax
   0x000000000040115a <+51>:	jne    0x401144 <phase_5+29>
```
由赋的值可以看出%eax和%dex存的是值，应该为循环变量,记为`int ax=0,dx=0;`，而%ecx存的是地址,记为`char * cx = bx`，这段操作可写成c语言。
```c
int ax = 0，dx=0;
char * cx = bx = s;
while(ax<6){
    cx &=0xf;;
    dx = ((int *) 0x402600)[cx];
    ax +=1;
}
```
可见0x402600处有一个数组，记为`int *ar`，这段操作以将输入字符串中的每个字符的低4为为索引，引用6次ar中的数据，求和存在dx中。
通过`x /16wd 0x402600`查看数组，得
```
0x402600 <array.3162>:	2	10	6	1
0x402610 <array.3162+16>:	12	16	9	3
0x402620 <array.3162+32>:	4	7	14	5
0x402630 <array.3162+48>:	11	8	15	13
```
最后
```
   0x000000000040115c <+53>:	cmp    $0x2b,%edx
   0x000000000040115f <+56>:	je     0x401166 <phase_5+63>
   0x0000000000401161 <+58>:	call   0x401629 <explode_bomb>
   0x0000000000401166 <+63>:	pop    %rbx
   0x0000000000401167 <+64>:	ret   
``` 
故dx必须为0x2b，即43.注意到数组ar中有`ar[0]=2;ar[1]==10;ar[3]=1;`,并且10*4+2+1 == 43,所以输入字符的ASCII码对16取模分别为1,1,1,1,0,3即可。
故答案为`'AAAA@C'`
### phase_6
**第一部分**
```
    0x0000000000401168 <+0>:	push   %r13
   0x000000000040116a <+2>:	push   %r12
   0x000000000040116c <+4>:	push   %rbp
   0x000000000040116d <+5>:	push   %rbx
   0x000000000040116e <+6>:	sub    $0x58,%rsp
   0x0000000000401172 <+10>:	lea    0x30(%rsp),%rsi
   0x0000000000401177 <+15>:	call   0x40165f <read_six_numbers>
   ```
读取六个数字，存在栈中。由`0x30(%rsp),%rsi`可知第一个数存在0x30(%rsp)处，记这个数组为`int ar[6];`

**第二部分**

从<+31>到<+100>是一个二重循环，其关键操作为`cmp    %eax,0x0(%rbp)	jne 0x4011c0 <phase_6+88>  call   0x401629 <explode_bomb>`，即各个元素不能相同，且都必须小于等于6，所以数组中存放的是1到6的一个排列。随后跳到<+134>

**第三部分**

<+134>为一个循环的入口，从<+100>到<+153>又为一个二重循环。由 ` <+102>:	mov    0x8(%rdx),%rdx`可知操作的是一个链表，记该链表为`list`，由` $0x6042f0,%edx`可知链表的首地址为0x6042f0，输入`x /12xg 0x6042f0`查看链表,得
```
0x6042f0 <node1>:	0x00000001000000a6	0x0000000000604300
0x604300 <node2>:	0x00000002000002dc	0x0000000000604310
0x604310 <node3>:	0x00000003000003c9	0x0000000000604320
0x604320 <node4>:	0x00000004000003e1	0x0000000000604330
0x604330 <node5>:	0x0000000500000379	0x0000000000604340
0x604340 <node6>:	0x0000000600000311	0x0000000000000000
 ```
其中外层循环遍历数组ar，第i次的内层循环在rsp+i*8处存了链表list第ar[i]个节点的地址.故该二重循环的结果为在栈中存放了一个指针数组，大小为6，从%rsp开始，，每个元素为链表节点的地址，记该指针数组为` node *p[6]`,存放的对应关系为p[i]指向list链表的第ar[i]个节点。随后跳到<+155>

**第四部分**

<+155>到<+191>为一个循环,对链表进行了重排序，结果为：p[i]指向的节点的下一个节点为p[i+1]指向的节点。

**最后一部分**

<+193>到<+228>为一个循环,重排序的链表判断是否符合要求,要求为：链表的数据递减。
list链表为{166,732,969,993,889,785},故4为第一，随后是3，5，6，2，1
故答案为`4 3 5 6 2 1`
### phase_7
**phase_defused函数**

phase7在phase_defused阶段进入，
```
    0x00000000004017d5 <+14>:	cmpl   $0x6,0x202fc0(%rip)        # 0x60479c <num_input_strings>
   0x00000000004017dc <+21>:	jne    0x40184b <phase_defused+132>
   ```
0x202fc0(%rip) 必须为6，才能进入secret_phase。旁边注释说0x202fc0(%rip)处存了输入的字符串，故应该在phase_6后会进入secret_phase.经过打断点验证，果然如此。

<23>到<61>为第一个部分,以%rdi和%rsi为字符串参数调用<phase_defused>。查看知%esi存放的地址指向`"%d %d %s"`字符串。故应该读入2整数，一个字符串分别存在0xc(%rsp),0x8(%rsp),0x10(%rsp),依此记为`int i1.i2;char *s`。而查看%esi的存放值确发现为空。运行时断点查看，发现%esi处存了`"12 43"`的地址。故应该读取的是第四阶段的字符串。而必须读三个值，所以在第阶段要输入 `"12 43 (string)"`才能进入secret_phase。

<+63>到<+80>为判断输入，经查看%rsi中存放的地址指向`"DrEvil"`字符串，而程序以rds（存放字符串s的地址）和esi为参数调用了strings_not_equal。经过简单分析知s必须为`"DrEvil"`，故阶段四应该输入`"12 43 (string)"`，程序进入secret_phase

**secret_phase函数**

<0>到<37>先读取了一行输入，存在rdx中，记为`char * s1`。然后以rdi为参数调用了<strtol@plt>,根据上下文以及名字(string to long)判断这个函数应该是把字符串转化为数字，最后将数字到了%rbxz中。记为`long bx =strtol(s1)`.
接下来的是判断数字bx,必须有`bx - 1 <= 0x3e8`
<45>到<57>，调用了fun7，等价于`fun7(0x604110,bx)`,0x604110处的数据是什么尚不确定,暂时记为`long *p = 0x604110`.随后判断返回值，必须有`fun7(0x604110,bx) == 3`

**fun7为一个树搜索函数**

可以翻译成c语言
```c
fun7(long *di,long si){
    if (di == NULL){
        return 0xffffffff;
    }
    long dx = *di;
    if(dx>si){
        return 2 * fun(*(di + 1), si) ;  //递归进入左子树
    } else if (dx < si){
        return 2 * fun(*(di + 2), si) +1; //递归进入右子树
    } else {
        return 0;
    }
}
```
注意到有2*(2*0+1)+1 == 3，故路径为
1. dx < si
2. dx < si 
3. dx = si
现在知道0x604110存放的应该是树的根的地址，输入` x /60xg 0x604110`得
```
0x604110 <n1>:	0x0000000000000024	0x0000000000604130
0x604120 <n1+16>:	0x0000000000604150	0x0000000000000000
0x604130 <n21>:	0x0000000000000008	0x00000000006041b0
0x604140 <n21+16>:	0x0000000000604170	0x0000000000000000
0x604150 <n22>:	0x0000000000000032	0x0000000000604190
0x604160 <n22+16>:	0x00000000006041d0	0x0000000000000000
0x604170 <n32>:	0x0000000000000016	0x0000000000604290
0x604180 <n32+16>:	0x0000000000604250	0x0000000000000000
0x604190 <n33>:	0x000000000000002d	0x00000000006041f0
0x6041a0 <n33+16>:	0x00000000006042b0	0x0000000000000000
0x6041b0 <n31>:	0x0000000000000006	0x0000000000604210
0x6041c0 <n31+16>:	0x0000000000604270	0x0000000000000000
0x6041d0 <n34>:	0x000000000000006b	0x0000000000604230
0x6041e0 <n34+16>:	0x00000000006042d0	0x0000000000000000
0x6041f0 <n45>:	0x0000000000000028	0x0000000000000000
0x604200 <n45+16>:	0x0000000000000000	0x0000000000000000
0x604210 <n41>:	0x0000000000000001	0x0000000000000000
0x604220 <n41+16>:	0x0000000000000000	0x0000000000000000
0x604230 <n47>:	0x0000000000000063	0x0000000000000000
0x604240 <n47+16>:	0x0000000000000000	0x0000000000000000
0x604250 <n44>:	0x0000000000000023	0x0000000000000000
0x604260 <n44+16>:	0x0000000000000000	0x0000000000000000
0x604270 <n42>:	0x0000000000000007	0x0000000000000000
0x604280 <n42+16>:	0x0000000000000000	0x0000000000000000
0x604290 <n43>:	0x0000000000000014	0x0000000000000000
0x6042a0 <n43+16>:	0x0000000000000000	0x0000000000000000
0x6042b0 <n46>:	0x000000000000002f	0x0000000000000000
0x6042c0 <n46+16>:	0x0000000000000000	0x0000000000000000
0x6042d0 <n48>:	0x00000000000003e9	0x0000000000000000
0x6042e0 <n48+16>:	0x0000000000000000	0x0000000000000000
```
该树可画成下图,可见该树为一棵二叉搜索树。
![](https://raw.githubusercontent.com/HJLomega/bomblab_picture/master/8689d70fb4d33c5951abe8869c88fa0.jpg)
故经过两次进入右子树后找到dx==si，所以si应该是6b。应该输入十进制数。
故答案为`105`

综上所述，所有的phase答案是
```
Public speaking is very easy.
0 1 3 6 10 15
0 t 770 
12 43 DrEvil
@AAAAC
4 3 5 6 2 1
105
 ```